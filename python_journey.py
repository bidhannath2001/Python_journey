# -*- coding: utf-8 -*-
"""python_journey.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mrqpfi8TvmgwXzU8MqrVjxCpkRWGvdAF

#Queue
"""

size=5
def Enqueue(Q,val):
  if len(Q)==size:
    print('Overflow! Queue is full!')
    return
  else:
    Q.append(val)
    print('After Enqueue operation; ',Q)
  print(len(Q))

def Dequeue(Q):
  if not Q:
    print('Underflow! Queue is empty!')
    return
  else:
    item=Q.pop(0)
    print('Delete item:',item)
    print('After Dequeue: ',Q)

Q=[]

Enqueue(Q,5)
Enqueue(Q,10)
Enqueue(Q,15)
Enqueue(Q,20)
Enqueue(Q,25)
Enqueue(Q,50)
Enqueue(Q,50)

Dequeue(Q)
Dequeue(Q)
Dequeue(Q)
Dequeue(Q)
Dequeue(Q)
Dequeue(Q)

#H.W =  sorting with priority order

"""#stack"""

#create stack
def create():
    item = []
    return item

#push function
def push(item,value):
    item.append(value)
    print('After push operation: ',item)

#pop function
def pop_s(item):
    N = len(item)
    if N == 0:
        print('Stack empth!')
    else:
        p = item.pop()
        print('After pop operation: ',item)
        return p

#find top
def top(item):
    N = len(item)
    return item[N-1]

#reverse function
def reverse(item,string):
    N = len(string)
    for i in range(N):
        push(item,string[i])

    rev_str = ''
    for i in range(N):
        rev_str = rev_str + pop_s(item)
    print(rev_str)

def infix_to_postfix(item,infix):
    op = ['+','-','*','/','%','^']
    b = ['(',')']
    p = {'+':1, '-':1,'*':2,'/':2,'%':2,'^':3}
    postfix = ''
    N = len(infix)
    for c in infix:
        if c not in op and c not in b:
            postfix = postfix + c
        elif c == '(':
            push(item,c)
        elif c == ')':
            while item and item[-1] not in '(':
                postfix = postfix + pop_s(item)
            pop_s(item)
        else:
            while item and item[-1]!='(' and p[c] <= p[item[-1]]:
                postfix = postfix + pop_s(item)
            push(item,c)
    while item:
        postfix = postfix + pop_s(item)
    print('Postfix = ',postfix)
    print('Evaluate = ',evaluate(item,postfix))
    #pop_s(item)

def evaluate(item,postfix):
    op = ['+','-','*','/','%','^']
    for i in postfix:
        if i not in op:
            push(item,i)
        else:
            a = pop_s(item)
            b = pop_s(item)
            if i == '+':
                res = int(a) + int(b)
                push(item,res)
            if i == '-':
                res = int(a) - int(b)
                push(item,res)
            if i == '*':
                res = int(a) * int(b)
                push(item,res)
            if i == '/':
                res = int(a) / int(b)
                push(item,res)
    return item

stack = create()
string = '6+(5*9)'
string1= 'A+B-c(A/D)'
infix_to_postfix(stack, string)
#reverse(stack,string1)

"""#KMP pattern matching"""

def LPS_table(p):
  n=len(p)
  lps=[0]*n
  i=0
  j=1
  lps[0]=0
  for j in range(1,n):
    if(p[i]==p[j]):
      lps[j]=i+1
      i+=1
      j+=1
    else:
      if i==0:
        lps[j]=0
        j+=1
      else:
        i=lps[i-1]
  return lps
  #print(lps)
def kmp(t,p):
  lps=LPS_table(p)
  i=0
  j=0
  flag=0
  m=len(t)
  n=len(p)
  while i<m:
    if t[i]==p[j]:
      i+=1
      j+=1
    else:
      if j!=0:
        j=lps[j-1]
      else:
        i+=1
    if(j==n):
      print("Found at index = ",i-n)
      flag+=1
      j=lps[j-1]
  if flag==0:
    print("Pattern not found!")
t="ABCDABDABCDAB"
p="p"
#LPS_table(p)
kmp(t,p)

"""#pattern_matching"""

def naive_search(txt,pat):
  m=len(txt)
  n=len(pat)
  for i in range(m-n+1):
    for j in range(n):
      if(txt[i+j]!=pat[j]):
        break
      if j==n-1:
        print("Pattern found at index ",i)
txt=input(("Input txt: "))
pat=input(("Input pat: "))
naive_search(txt,pat)

"""#linked list"""

#class
class student:
  def __init__(self,id,name):
    self.id= id
    self.name= name

  def student_info(self):
    print("Student ID: "+ str(self.id)+" and student name: "+self.name)

  def student_result(self):
    print("student result")

student1=student(1027,'Bidhan')
student2=student(1002,'Void')
print(student1.name)
print(student1.id)
print(student1.student_info())

"""#Doubly Linked list"""

#node creation
class node:
  def __init__(self,data):
    self.prev=None
    self.data=data
    self.next=None

class D_Linked_List:
  def __init__(self):
    self.head = None

  def traverse(self,head):
    print(head.data)
    temp=head.next
    while temp!=head:
      print(temp.data)
      temp=temp.next

first = node(10)
second = node(20)
third = node(30)


L=D_Linked_List()
L.head = first
first.next = second
second.next = third
second.prev=first
third.next=L.head
third.prev=second

#print linked list
temp=L.head
L.traverse(temp)

"""#Circular linked list"""

#node creation
class node:
  def __init__(self,data):
    self.data=data
    self.next=None

class C_Linked_List:
  def __init__(self):
    self.head = None

  def traverse(self,head):
    print(head.data)
    temp=head.next
    while temp!=head:
      print(temp.data)
      temp=temp.next

first = node(10)
second = node(20)
third = node(30)


L=C_Linked_List()
L.head = first
first.next = second
second.next = third
third.next=L.head

#print linked list
temp=L.head
L.traverse(temp)

"""#Linked List (lab class)"""

#node creation
class node:
  def __init__(self,data):
    self.data=data
    self.next=None

class Linked_List:
  def __init__(self):
    self.head = None

  def traverse(self,head):
    while head !=None:
      print(head.data)
      head = head.next
  def delete_by_loc(self,head,pos):
    prev=head
    c=1
    while prev.next!=None:
      if c==pos-1:
        break
      else:
        prev=prev.next
        c=c+1
    cur=prev.next
    prev.next=cur.next

first = node(10)
second = node(20)
third = node(30)
new_node = node(40)
end_node=node(50)
middle_node=node(100)

L=Linked_List()
L.head = first
first.next = second
second.next = third

new_node.next=L.head
L.head = new_node

#end node
third.next=end_node
t=L.head
while t!=None:
  if t.data==20:
    break;
  else:
    t= t.next

middle_node.next=t.next
t.next=middle_node

#count nodes
t1=L.head
c=1
while t1!=None:
  if c==4:
    t1.data=80;
    break
  else:
    t1= t1.next
    c=c+1
t1.data=80
'''
c=1
t1=L.head
while c!=4:
  t1=t1.next
  c=c+1
t1.data=80

'''
#delete from begining
L.head = new_node.next

#delete from ending
t2=L.head
while t2.next.next!=None:
  t2 = t2.next
t2.next=None

#delete from middle/delete by value
prev=L.head
flag=0
while prev.next.next!=None:
  if prev.next.data==20:
    flag=1
    break
  else:
    prev=prev.next
cur=prev.next
if flag==1:
  prev.next=cur.next
  #upade
  #cur.data=100
else:
  print("Deletion not possible!")

#delete by address

L.delete_by_loc(L.head,2)
'''temp=L.head
cnt=1
while temp.next!=None:
  if cnt==2:
    temp.next=temp.next.next
    break
  else:
    temp=temp.next
    cnt=cnt+1
'''
#print linked list
temp=L.head
L.traverse(temp)

"""#Linked list assignment"""

# node creation
class node:
    def __init__(self, data):
        self.data = data
        self.next = None


# Linked list create
class Linked_List:
    def __int__(self):
        self.head = None

    # traversal function
    def traverse(self, head):
        while head is not None:
            print(head.data)
            head = head.next

    def beginning_node(self, data):
        data.next = L.head
        L.head = data

    def middle_node(self, data, pos):
        temp = L.head
        count = 1
        while temp is not None:
            if count == pos:
                break
            else:
                temp = temp.next
                count += 1
        data.next = temp.next
        temp.next = data

    def ending_node(self, data):
        temp = L.head
        while temp.next is not None:
            temp = temp.next
        temp.next = data

    def delete_beginning(self):
        temp = L.head
        L.head = temp.next

    def delete_middle(self, pos):
        temp = L.head
        count = 1
        while temp.next is not None:
            if count == pos - 1:
                break
            else:
                temp = temp.next
                count += 1
        cur = temp.next
        temp.next = cur.next

    def delete_by_value(self, value):
        temp = L.head
        flag = 0
        while temp.next.next is not None:
            if temp.next.data == value:
                flag = 1
                break
            else:
                temp=temp.next
        cur = temp.next
        if flag == 1:
            temp.next = cur.next
        else:
            print(f"{value} delete is not possible!")

    def delete_from_ending(self):
        temp = L.head
        while temp.next.next is not None:
            temp = temp.next
        temp.next = None

first = node(10)
second = node(20)
third = node(30)

# Insertion part
# node add at the beginning
beg_node = node(5)

# node add at specific position
mid_node = node(25)

# node add at the ending
end_node = node(40)

L = Linked_List()
L.head = first
first.next = second
second.next = third

# node add at the beginning
'''beg_node.next = L.head
L.head = beg_node'''
L.beginning_node(beg_node)

# node add at specific position
'''pos = 3
temp = L.head
count = 1
while temp is not None:
    if count == pos:
        break
    else:
        temp = temp.next
        count += 1
mid_node.next = temp.next
temp.next = mid_node'''
L.middle_node(mid_node, 3)

# node add at the ending
'''temp = L.head
while temp.next is not None:
    temp = temp.next
temp.next = end_node'''
L.ending_node(end_node)

# deletion part
# delete from beginning
'''temp = L.head
L.head = temp.next'''
L.delete_beginning()

# delete from specific position
'''count = 1
pos = 3
temp = L.head
while temp.next is not None:
    if count == pos - 1:
        break
    else:
        temp = temp.next
        count += 1
cur = temp.next
temp.next = cur.next'''
L.delete_middle(3)

# delete by value
'''temp = L.head
value = 20
flag = 0
while temp.next.next is not None:
    if temp.next.data == value:
        flag = 1
        break
    else:
        temp = temp.next
cur = temp.next
if flag == 1:
    temp.next = cur.next
else:
    print(f"{value} Delete is not possible!")'''
value = 20
L.delete_by_value(value)

# delete form ending
'''temp = L.head
while temp.next.next is not None:
    temp = temp.next
temp.next = None'''
L.delete_from_ending()

# print linked list
temp = L.head
L.traverse(temp)

def insertion_sort(A):
  N=len(A)
  for i in range(1,N):
    temp=A[i]
    j=i
    while j>0 and A[j-1]>temp:
      A[j] = A[j-1]
      j=j-1
    A[j]=temp
A=[5,4,1,2,3]
insertion_sort(A)
print(A)

"""#Bubble sort"""

def bubble_sort(A):
  N=len(A)
  for i in range(N):
    for j in range(1,N-i):
      if A[j-1]>A[j]:
        temp =  A[j-1]
        A[j-1] = A[j]
        A[j] = temp
A=[5,4,1,3,2]
bubble_sort(A)
print("Sorted list A: ",A)

"""#Selection_Sort"""

def selection_sort(A):
  N = len(A)
  for i in range (N):
    min = i
    for j in range(i+1,N):
      if A[j]<A[min]:
        min = j
    temp=A[i]
    A[i]=A[min]
    A[min]=temp
A=[3,9,5,8,7]
selection_sort(A)
print("Sorting list: ",A)

def traversal(a, n):
    for i in range(n + 1):
        print(a[i], end= ' ')


def insertion(a, n, k, item):
    for j in range(n-1, k-1, -1):
        a[j+1] = a[j]
    a[k] = item
    traversal(a, n)


from array import *
a = array('i', [])
n = int(input("Number of element: "))
k = int(input("Enter an index number where you want to insert: "))
item = int(input("Enter a number which you want to insert: "))
for i in range(n+1):
    if i == n:
        a.append(-1)
    else:
        a.append(int(input("Enter element ")))

insertion(a, n, k, item)

"""#delation"""

A=[10,20,30,40,50]
k=2
n=len(A)
for i in range(k,n-1):
  A[i]=A[i+1]
for i in range(n-1):
  print(A[i],end=' ')

"""#binary_Search"""

def binary_search(A,N,S):
  st=0
  end=N-1
  mid=int((st+end)/2)
  pos=-1
  while st<=end:
    if A[mid]==S:
      pos=mid
      break
    elif S<A[mid]:
      end=mid-1
    elif S>A[mid]:
      st=mid+1
    mid=int((st+end)/2)
  if pos==-1:
    print("Element not found!")
  else:
    print(pos)
A=[10,20,30,40,50]
N=len(A)
S=20
loc=binary_search(A,N,S)

"""#check grade"""

number = int (input('Enter a number'))
if number>100 or number<0:
  print("Invalid number")
elif number>=80 and number<=100:
  print("A+")
elif number>=75 and number<=79:
  print("A")
elif number>=70 and number<=74:
  print("A-")
elif number>=65 and number<=69:
  print("B+")
elif number>=60 and number<=64:
  print("B")
elif number>=55 and number<=59:
  print("B-")
elif number>=50 and number<=54:
  print("C+")
elif number>=45 and number<=49:
  print("C")
elif number>=40 and number<=44:
  print("D")
else:
  print("F")

"""#loop"""

numbers=[]
n = int(input('Enter a number'))
for i in range(2,n,2):
  numbers.append(i)
print(numbers)

"""#prime number"""

prime_numbers=[]
n= int(input('Enter a number: '))
for i in range(2,n+1):
  status=0
  for j in range(2,i):
    if i%j==0:
      status=1
      break
  if status==0:
    prime_numbers.append(i)
print(prime_numbers)